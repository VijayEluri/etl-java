doctype public "-//IDN etl.sf.net//ETL//Grammar 0.3.0";
/// The statement below is a special blank statement to ensure that it is ignored.
;
/// This is almost minimal grammar that supports HelloWorld.ej.etl
/// But there are still some features to remove.
grammar net.sf.etl.tests.data.MinimalEJ {
	namespace default ej = "http://etl.sf.net/2006/samples/ej/0.1";
	
	/// A common context that defines documentation and attributes
	context Common {
		/// Simple documentation 
		documentation Documentation {
			@ documentation += doclines wrapper ej:DocumentationLine.text;
		};

		/// Simple attributes definition
		attributes Attributes {
			@ attributeSets += {
				^ ej:AttributeSet {
					% @ {
						@ attributes += list , {
							expression(Expression,precedence=100);
						};
					};
				};
			}+;
		};

		def IdentifierDef {
			^ ej:Identifier {
				@ value = identifier;
			};
		};
	};
	
	context abstract Classifiers {
		include Common;

		statement ClassStatement {
			% class;
			modifiers wrapper ej:Modifier.value {
				@ visibilityModifier = modifier public;
			};
			@ name = ref(IdentifierDef);
			@ contents += block(ClassContents);
		};
	};
	
	/// Top level context that contains package and class definitions
	context default TopLevel {
		include Classifiers wrapper ej:TopLevelClassifier.classifier;
		
		statement PackageStatement {
			% package;
			@ name = expression(PackageNameExpression);
		};
		
		
		statement BlankTopLevel {
		};
	};

	
	context PackageNameExpression {
		include Common;
				
		op composite Identifier(f) {
			ref(IdentifierDef);
		};
		
		op AccessOp(yfx, 100, . ) {
			@ accessed = left;
			@ feature = right;
		};
	};

	
	context TypeExpression {
		include PackageNameExpression;
		
		op composite VoidType(f) {
			^ ej:PrimitiveType {
				@ name = token(void);
			};
		};
		
		op composite ArrayType(f) {
			^ ej:PrimitiveType {
				@ name = token(array);
			};
		};
		
		op composite ApplySquareOp(yf, 100) {
			@ functor = left;
			@ args += % [ {
				list , {
					expression;
				};
			} % ];
		};
		
	};
	
	context Expression {
		include TypeExpression;

		op composite StringLiteral(f) {
			@ value = string(quote='\"');
		};

		op composite ApplyRoundOp(yf, 100) {
			@ functor = left;
			@ args += % ( {
				list , {
					expression;
				};
			} %);
		};
	};
	
	context Code {
		statement ExpressionStatement {
			@ expression = expression(Expression);
		};
		statement BlankCode {
		};
	};
	
	context ClassContents {
		include Common;
		
		statement MethodStatement {
			% to;
			modifiers wrapper ej:Modifier.value {
				@ visibilityModifier = modifier public;
				@ staticModifier = modifier static;
			};
			@ returnType = expression(TypeExpression);
			@ name = ref(IdentifierDef);
			@ parameters += % ( {
				list , {
					^ ej:Parameter {
						@ classifier = expression(TypeExpression);
						@ name = ref(IdentifierDef);
					};
				}?;
			} % );
			@ body = ref(MethodBlock);
		};
		
		def MethodBlock {
			^ ej:MethodBlock {
				@ content += block(Code);
			};
		};
		
		statement BlankClassContent {
		};
	};
};